/*
	This file is part of Retro Graphics Toolkit

	Retro Graphics Toolkit is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or any later version.

	Retro Graphics Toolkit is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with Retro Graphics Toolkit. If not, see <http://www.gnu.org/licenses/>.
	Copyright Sega16 (or whatever you wish to call me) (2012-2015)
*/
/**
 *
 * MACHINE GENERATED FILE. DO NOT EDIT.
 *
 * Bindings for library undo
 *
 * This file has been generated by dub 2.2.3.
 */
#include "dub/dub.h"
#include "undo.h"


extern "C" {
}

/** void pushTile(unsigned int id, tileTypeMask_t type)
 * inc/undo.h:9
 */
static int undo_pushTile(lua_State *L) {
  try {
    unsigned int id = dub::checkinteger(L, 1);
    tileTypeMask_t type = (tileTypeMask_t)dub::checkinteger(L, 2);
    pushTile(id, type);
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.pushTile: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.pushTile: Unknown exception");
  }
  return lua_error(L);
}

/** void pushTilenew(unsigned int id)
 * inc/undo.h:10
 */
static int undo_pushTilenew(lua_State *L) {
  try {
    unsigned int id = dub::checkinteger(L, 1);
    pushTilenew(id);
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.pushTilenew: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.pushTilenew: Unknown exception");
  }
  return lua_error(L);
}

/** void pushTilePixel(unsigned int id, unsigned int x, unsigned int y, tileTypeMask_t type)
 * inc/undo.h:11
 */
static int undo_pushTilePixel(lua_State *L) {
  try {
    unsigned int id = dub::checkinteger(L, 1);
    unsigned int x = dub::checkinteger(L, 2);
    unsigned int y = dub::checkinteger(L, 3);
    tileTypeMask_t type = (tileTypeMask_t)dub::checkinteger(L, 4);
    pushTilePixel(id, x, y, type);
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.pushTilePixel: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.pushTilePixel: Unknown exception");
  }
  return lua_error(L);
}

/** void pushTileGroupPrepare(tileTypeMask_t type)
 * inc/undo.h:12
 */
static int undo_pushTileGroupPrepare(lua_State *L) {
  try {
    tileTypeMask_t type = (tileTypeMask_t)dub::checkinteger(L, 1);
    pushTileGroupPrepare(type);
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.pushTileGroupPrepare: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.pushTileGroupPrepare: Unknown exception");
  }
  return lua_error(L);
}

/** void addTileGroup(unsigned int tile, int forceid=-1)
 * inc/undo.h:13
 */
static int undo_addTileGroup(lua_State *L) {
  try {
    int top__ = lua_gettop(L);
    if (top__ >= 2) {
      unsigned int tile = dub::checkinteger(L, 1);
      int forceid = dub::checkinteger(L, 2);
      addTileGroup(tile, forceid);
      return 0;
    } else {
      unsigned int tile = dub::checkinteger(L, 1);
      addTileGroup(tile);
      return 0;
    }
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.addTileGroup: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.addTileGroup: Unknown exception");
  }
  return lua_error(L);
}

/** void pushTileappendGroupPrepare(void)
 * inc/undo.h:14
 */
static int undo_pushTileappendGroupPrepare(lua_State *L) {
  try {
    pushTileappendGroupPrepare();
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.pushTileappendGroupPrepare: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.pushTileappendGroupPrepare: Unknown exception");
  }
  return lua_error(L);
}

/** void pushTilesAll(tileTypeMask_t type)
 * inc/undo.h:15
 */
static int undo_pushTilesAll(lua_State *L) {
  try {
    tileTypeMask_t type = (tileTypeMask_t)dub::checkinteger(L, 1);
    pushTilesAll(type);
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.pushTilesAll: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.pushTilesAll: Unknown exception");
  }
  return lua_error(L);
}

/** void pushTileAppend(void)
 * inc/undo.h:16
 */
static int undo_pushTileAppend(lua_State *L) {
  try {
    pushTileAppend();
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.pushTileAppend: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.pushTileAppend: Unknown exception");
  }
  return lua_error(L);
}

/** void pushTilemapEdit(unsigned int x, unsigned int y)
 * inc/undo.h:17
 */
static int undo_pushTilemapEdit(lua_State *L) {
  try {
    unsigned int x = dub::checkinteger(L, 1);
    unsigned int y = dub::checkinteger(L, 2);
    pushTilemapEdit(x, y);
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.pushTilemapEdit: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.pushTilemapEdit: Unknown exception");
  }
  return lua_error(L);
}

/** void pushTilemapResize(unsigned int wnew, unsigned int hnew)
 * inc/undo.h:18
 */
static int undo_pushTilemapResize(lua_State *L) {
  try {
    unsigned int wnew = dub::checkinteger(L, 1);
    unsigned int hnew = dub::checkinteger(L, 2);
    pushTilemapResize(wnew, hnew);
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.pushTilemapResize: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.pushTilemapResize: Unknown exception");
  }
  return lua_error(L);
}

/** void pushTilemapBlocksAmt(unsigned int amtnew)
 * inc/undo.h:19
 */
static int undo_pushTilemapBlocksAmt(lua_State *L) {
  try {
    unsigned int amtnew = dub::checkinteger(L, 1);
    pushTilemapBlocksAmt(amtnew);
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.pushTilemapBlocksAmt: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.pushTilemapBlocksAmt: Unknown exception");
  }
  return lua_error(L);
}

/** void pushTilemapAll(bool attrOnly)
 * inc/undo.h:20
 */
static int undo_pushTilemapAll(lua_State *L) {
  try {
    bool attrOnly = dub::checkboolean(L, 1);
    pushTilemapAll(attrOnly);
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.pushTilemapAll: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.pushTilemapAll: Unknown exception");
  }
  return lua_error(L);
}

/** void pushTilemapPlaneDelete(unsigned int plane)
 * inc/undo.h:21
 */
static int undo_pushTilemapPlaneDelete(lua_State *L) {
  try {
    unsigned int plane = dub::checkinteger(L, 1);
    pushTilemapPlaneDelete(plane);
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.pushTilemapPlaneDelete: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.pushTilemapPlaneDelete: Unknown exception");
  }
  return lua_error(L);
}

/** void pushTilemapPlaneAdd(unsigned int plane)
 * inc/undo.h:22
 */
static int undo_pushTilemapPlaneAdd(lua_State *L) {
  try {
    unsigned int plane = dub::checkinteger(L, 1);
    pushTilemapPlaneAdd(plane);
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.pushTilemapPlaneAdd: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.pushTilemapPlaneAdd: Unknown exception");
  }
  return lua_error(L);
}

/** void pushExtAttrs(unsigned int plane)
 * inc/undo.h:23
 */
static int undo_pushExtAttrs(lua_State *L) {
  try {
    unsigned int plane = dub::checkinteger(L, 1);
    pushExtAttrs(plane);
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.pushExtAttrs: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.pushExtAttrs: Unknown exception");
  }
  return lua_error(L);
}

/** void pushPaletteEntry(unsigned int id)
 * inc/undo.h:24
 */
static int undo_pushPaletteEntry(lua_State *L) {
  try {
    unsigned int id = dub::checkinteger(L, 1);
    pushPaletteEntry(id);
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.pushPaletteEntry: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.pushPaletteEntry: Unknown exception");
  }
  return lua_error(L);
}

/** void pushPaletteAll(void)
 * inc/undo.h:25
 */
static int undo_pushPaletteAll(lua_State *L) {
  try {
    pushPaletteAll();
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.pushPaletteAll: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.pushPaletteAll: Unknown exception");
  }
  return lua_error(L);
}

/** void pushChunk(unsigned int id, bool rm)
 * inc/undo.h:26
 */
static int undo_pushChunk(lua_State *L) {
  try {
    unsigned int id = dub::checkinteger(L, 1);
    bool rm = dub::checkboolean(L, 2);
    pushChunk(id, rm);
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.pushChunk: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.pushChunk: Unknown exception");
  }
  return lua_error(L);
}

/** void pushChunksAll(void)
 * inc/undo.h:27
 */
static int undo_pushChunksAll(lua_State *L) {
  try {
    pushChunksAll();
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.pushChunksAll: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.pushChunksAll: Unknown exception");
  }
  return lua_error(L);
}

/** void pushChunkResize(unsigned int wnew, unsigned int hnew)
 * inc/undo.h:28
 */
static int undo_pushChunkResize(lua_State *L) {
  try {
    unsigned int wnew = dub::checkinteger(L, 1);
    unsigned int hnew = dub::checkinteger(L, 2);
    pushChunkResize(wnew, hnew);
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.pushChunkResize: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.pushChunkResize: Unknown exception");
  }
  return lua_error(L);
}

/** void pushChunkEdit(unsigned int id, unsigned int x, unsigned int y)
 * inc/undo.h:29
 */
static int undo_pushChunkEdit(lua_State *L) {
  try {
    unsigned int id = dub::checkinteger(L, 1);
    unsigned int x = dub::checkinteger(L, 2);
    unsigned int y = dub::checkinteger(L, 3);
    pushChunkEdit(id, x, y);
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.pushChunkEdit: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.pushChunkEdit: Unknown exception");
  }
  return lua_error(L);
}

/** void pushChunkAppend(void)
 * inc/undo.h:30
 */
static int undo_pushChunkAppend(lua_State *L) {
  try {
    pushChunkAppend();
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.pushChunkAppend: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.pushChunkAppend: Unknown exception");
  }
  return lua_error(L);
}

/** void pushChunkNew(unsigned int id)
 * inc/undo.h:31
 */
static int undo_pushChunkNew(lua_State *L) {
  try {
    unsigned int id = dub::checkinteger(L, 1);
    pushChunkNew(id);
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.pushChunkNew: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.pushChunkNew: Unknown exception");
  }
  return lua_error(L);
}

/** void pushSpriteAppend(unsigned int id)
 * inc/undo.h:32
 */
static int undo_pushSpriteAppend(lua_State *L) {
  try {
    unsigned int id = dub::checkinteger(L, 1);
    pushSpriteAppend(id);
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.pushSpriteAppend: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.pushSpriteAppend: Unknown exception");
  }
  return lua_error(L);
}

/** void pushSpriteAppendgroup(void)
 * inc/undo.h:33
 */
static int undo_pushSpriteAppendgroup(lua_State *L) {
  try {
    pushSpriteAppendgroup();
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.pushSpriteAppendgroup: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.pushSpriteAppendgroup: Unknown exception");
  }
  return lua_error(L);
}

/** void pushSpriteWidth(void)
 * inc/undo.h:34
 */
static int undo_pushSpriteWidth(lua_State *L) {
  try {
    pushSpriteWidth();
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.pushSpriteWidth: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.pushSpriteWidth: Unknown exception");
  }
  return lua_error(L);
}

/** void pushSpriteHeight(void)
 * inc/undo.h:35
 */
static int undo_pushSpriteHeight(lua_State *L) {
  try {
    pushSpriteHeight();
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.pushSpriteHeight: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.pushSpriteHeight: Unknown exception");
  }
  return lua_error(L);
}

/** void pushSpritePalrow(void)
 * inc/undo.h:36
 */
static int undo_pushSpritePalrow(lua_State *L) {
  try {
    pushSpritePalrow();
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.pushSpritePalrow: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.pushSpritePalrow: Unknown exception");
  }
  return lua_error(L);
}

/** void pushSpriteStarttile(void)
 * inc/undo.h:37
 */
static int undo_pushSpriteStarttile(lua_State *L) {
  try {
    pushSpriteStarttile();
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.pushSpriteStarttile: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.pushSpriteStarttile: Unknown exception");
  }
  return lua_error(L);
}

/** void pushSpriteLoadat(void)
 * inc/undo.h:38
 */
static int undo_pushSpriteLoadat(lua_State *L) {
  try {
    pushSpriteLoadat();
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.pushSpriteLoadat: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.pushSpriteLoadat: Unknown exception");
  }
  return lua_error(L);
}

/** void pushSpriteOffx(void)
 * inc/undo.h:39
 */
static int undo_pushSpriteOffx(lua_State *L) {
  try {
    pushSpriteOffx();
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.pushSpriteOffx: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.pushSpriteOffx: Unknown exception");
  }
  return lua_error(L);
}

/** void pushSpriteOffy(void)
 * inc/undo.h:40
 */
static int undo_pushSpriteOffy(lua_State *L) {
  try {
    pushSpriteOffy();
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.pushSpriteOffy: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.pushSpriteOffy: Unknown exception");
  }
  return lua_error(L);
}

/** void pushSpriteHflip(void)
 * inc/undo.h:41
 */
static int undo_pushSpriteHflip(lua_State *L) {
  try {
    pushSpriteHflip();
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.pushSpriteHflip: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.pushSpriteHflip: Unknown exception");
  }
  return lua_error(L);
}

/** void pushSpriteVflip(void)
 * inc/undo.h:42
 */
static int undo_pushSpriteVflip(lua_State *L) {
  try {
    pushSpriteVflip();
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.pushSpriteVflip: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.pushSpriteVflip: Unknown exception");
  }
  return lua_error(L);
}

/** void pushSpritePrio(void)
 * inc/undo.h:43
 */
static int undo_pushSpritePrio(lua_State *L) {
  try {
    pushSpritePrio();
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.pushSpritePrio: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.pushSpritePrio: Unknown exception");
  }
  return lua_error(L);
}

/** void pushProject(void)
 * inc/undo.h:44
 */
static int undo_pushProject(lua_State *L) {
  try {
    pushProject();
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.pushProject: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.pushProject: Unknown exception");
  }
  return lua_error(L);
}

/** void pushProjectAppend(void)
 * inc/undo.h:45
 */
static int undo_pushProjectAppend(lua_State *L) {
  try {
    pushProjectAppend();
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.pushProjectAppend: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.pushProjectAppend: Unknown exception");
  }
  return lua_error(L);
}

/** void pushProjectAll(void)
 * inc/undo.h:46
 */
static int undo_pushProjectAll(lua_State *L) {
  try {
    pushProjectAll();
    return 0;
  } catch (std::exception &e) {
    lua_pushfstring(L, "undo.pushProjectAll: %s", e.what());
  } catch (...) {
    lua_pushfstring(L, "undo.pushProjectAll: Unknown exception");
  }
  return lua_error(L);
}

// --=============================================== FUNCTIONS
static const struct luaL_Reg undo_functions[] = {
  { "pushTile"     , undo_pushTile        },
  { "pushTilenew"  , undo_pushTilenew     },
  { "pushTilePixel", undo_pushTilePixel   },
  { "pushTileGroupPrepare", undo_pushTileGroupPrepare },
  { "addTileGroup" , undo_addTileGroup    },
  { "pushTileappendGroupPrepare", undo_pushTileappendGroupPrepare },
  { "pushTilesAll" , undo_pushTilesAll    },
  { "pushTileAppend", undo_pushTileAppend  },
  { "pushTilemapEdit", undo_pushTilemapEdit },
  { "pushTilemapResize", undo_pushTilemapResize },
  { "pushTilemapBlocksAmt", undo_pushTilemapBlocksAmt },
  { "pushTilemapAll", undo_pushTilemapAll  },
  { "pushTilemapPlaneDelete", undo_pushTilemapPlaneDelete },
  { "pushTilemapPlaneAdd", undo_pushTilemapPlaneAdd },
  { "pushExtAttrs" , undo_pushExtAttrs    },
  { "pushPaletteEntry", undo_pushPaletteEntry },
  { "pushPaletteAll", undo_pushPaletteAll  },
  { "pushChunk"    , undo_pushChunk       },
  { "pushChunksAll", undo_pushChunksAll   },
  { "pushChunkResize", undo_pushChunkResize },
  { "pushChunkEdit", undo_pushChunkEdit   },
  { "pushChunkAppend", undo_pushChunkAppend },
  { "pushChunkNew" , undo_pushChunkNew    },
  { "pushSpriteAppend", undo_pushSpriteAppend },
  { "pushSpriteAppendgroup", undo_pushSpriteAppendgroup },
  { "pushSpriteWidth", undo_pushSpriteWidth },
  { "pushSpriteHeight", undo_pushSpriteHeight },
  { "pushSpritePalrow", undo_pushSpritePalrow },
  { "pushSpriteStarttile", undo_pushSpriteStarttile },
  { "pushSpriteLoadat", undo_pushSpriteLoadat },
  { "pushSpriteOffx", undo_pushSpriteOffx  },
  { "pushSpriteOffy", undo_pushSpriteOffy  },
  { "pushSpriteHflip", undo_pushSpriteHflip },
  { "pushSpriteVflip", undo_pushSpriteVflip },
  { "pushSpritePrio", undo_pushSpritePrio  },
  { "pushProject"  , undo_pushProject     },
  { "pushProjectAppend", undo_pushProjectAppend },
  { "pushProjectAll", undo_pushProjectAll  },
  { NULL, NULL},
};

// --=============================================== CONSTANTS
static const struct dub::const_Reg undo_const[] = {
  { "tTypeTile"    , ::tTypeTile          },
  { "tTypeTruecolor", ::tTypeTruecolor     },
  { "tTypeBoth"    , ::tTypeBoth          },
  { "tTypeDeleteFlag", ::tTypeDeleteFlag    },
  { "tTypeDelete"  , ::tTypeDelete        },
  { NULL, 0},
};

int luaopen_undoLua(lua_State *L) {
  lua_newtable(L);
  // <lib>
  // register global constants
  dub::register_const(L, undo_const);
  dub::fregister(L, undo_functions);
  // <lib>

  
  // <lib>
  return 1;
}
